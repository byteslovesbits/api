const express = require("express");
const cors = require("cors");
const User = require("../database/models/userModel");
const authenticateUser = require("../middleware/authenticateUser");

const userRouter = new express.Router();

// CREATE
userRouter.post("/users", async (req, res) => {
  const user = new User(req.body);
  try {
    await user.save();
    const jwt = await user.makeJWT();
    // 201 is semantically a creation code -
    res.status(201).send({ user, jwt: jwt });
  } catch (error) {
    res.status(400).send(error);
  }
});

userRouter.post("/users/login", async (req, res) => {
  try {
    const user = await User.findByEmailAndPassword(
      req.body.email,
      req.body.password
    );
    const jwt = await user.makeJWT();
    res.send({ user, jwt: jwt });
  } catch (error) {
    res.status(401).send(error);
  }
});

userRouter.post("/users/logout", authenticateUser, async (req, res) => {
  try {
    req.user.jsonWebTokens = req.user.jsonWebTokens.filter((jwt) => {
      return jwt.jwt !== req.jwt;
    });
    await req.user.save();

    res.send(user);
  } catch (error) {
    res.status(500).send(error);
  }
});

userRouter.post("/users/logoutAll", authenticateUser, async (req, res) => {
  // This feature is for when a user has logged in multiple times and gives them the option to logout from all devices. Many
  // web apps provide such a feature. Fore example, netflix has the option to logout from all devices and provided a quick and
  // easy method to secure your account.
  try {
    req.user.jsonWebTokens = [];
    res.send(req.user);
    await req.user.save();
  } catch (e) {
    res.status(500).send();
  }
});

// READ
userRouter.get("/users/myProfile", authenticateUser, async (req, res) => {
  // Attaching the user to the request object within authenticateUser means we don't have to query the database again to get the
  // user as we already have them and we know they are authenticated as the authenticateUser middleware has called next()
  res.send(req.user);
});

// UPDATE
userRouter.patch("/users/myProfile", authenticateUser, async (req, res) => {
  // Provide a better validation response to the client if they attempt to update invalid properties
  // If an incoming update is not in the permitted updates list then throw an error with a more specific error message

  // Object.keys() returns an array whose elements are strings corresponding to the enumerable properties found directly upon object. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
  const updatesRequested = Object.keys(req.body);

  // This array can change over time as the userSchema is developed further. We should never be able to update the jsonWebTokens array for example as this is generated by the jsonWebTokens
  // library
  const permittedUpdates = ["name", "email", "password"];

  const isValidUpdate = updatesRequested.every((update) =>
    permittedUpdates.includes(update)
  );

  if (!isValidUpdate) {
    return res
      .status(400)
      .send({ Error: "You have attempted to perform an invalid update!" });
  }

  try {
    // We already added the user to the request object within authenticateUser so
    // this line of code is an unnecessary database query
    // const updatedUser = await User.findById(req.params.id);
    updatesRequested.forEach(
      (requestedUpdate) =>
        (req.user[requestedUpdate] = req.body[requestedUpdate])
    );

    await req.user.save();

    // User already exists because we just authenticated the user within authenticateUser()
    // if (!updatedUser) {
    //   return res.status(404).send({ Error: "User not found!" });
    // }

    res.send(req.user);
  } catch (error) {
    res.status(400).send(error);
  }
});

// DELETE
userRouter.delete("/users/myProfile", authenticateUser, async (req, res) => {
  try {
    // We already have a user attached to the req object within authenticateUser so the next line is an unnecessary
    // database query. DRY PRINCIPLE APPLIES HERE ALONG WITH THE SINGLE RESPONSIBILITY PRINCIPLE IN authenticateUser
    // const deletedUser = await User.findByIdAndDelete(req.user._id);

    req.user.remove();
    res.send(req.user);
  } catch (error) {
    res.status(400).send();
  }
});

// // TESTING ROUTES
// userRouter.get("/users", authenticateUser, async (req, res) => {
//     // This route is for testing purposes only! There is never really a situation where a user should be able to get a
//     // list of all other user, unless you are admin.
//   try {
//     const users = await User.find({});
//     res.send(users);
//   } catch (error) {
//     res.status(500).send(error);
//   }
// });
//
// userRouter.get("/users/:id", async (req, res) => {
//   const id = req.params.id;
//
//   try {
//     const user = await User.findById(id);
//     if (!user) {
//       return res.status(404).send();
//     }
//     res.send(user);
//   } catch (error) {
//     res.status(500).send(error);
//   }
//

userRouter.get("/test", (req, res, next) => {
  res.send({ key: "Value" });
});

module.exports = userRouter;
